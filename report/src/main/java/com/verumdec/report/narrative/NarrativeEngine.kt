package com.verumdec.report.narrative

import com.verumdec.core.model.BehavioralAnomaly
import com.verumdec.core.model.BehavioralAnomalyType
import com.verumdec.core.model.Contradiction
import com.verumdec.core.model.ContradictionReport
import com.verumdec.core.model.ContradictionType
import com.verumdec.core.model.LegalTrigger
import com.verumdec.core.model.LegalTriggerEvidence
import com.verumdec.core.model.StatementIndex
import com.verumdec.core.model.TimelineConflict
import com.verumdec.core.model.TimelineEvent
import com.verumdec.entity.profile.EntityProfile
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

/**
 * NarrativeEngine generates a full forensic narrative from contradiction analysis.
 *
 * Takes:
 * - StatementIndex
 * - EntityProfiles
 * - Timeline events
 * - ContradictionReport
 *
 * And generates a full narrative text output that:
 * 1. Retells the entire case in chronological order
 * 2. Highlights key actors and their roles
 * 3. Inserts contradictions at the points they occur
 * 4. Explains the significance of each contradiction
 * 5. Merges behavioral analysis with factual analysis
 * 6. Outputs a clean, readable narrative suitable for legal review
 * 7. Uses plain-language forensic style, not technical jargon
 * 8. Ends with a summary of contradictions, risks, and legal implications
 */
class NarrativeEngine {
    
    companion object {
        /** Branding notice for report footer */
        const val BRANDING_NOTICE = "This report was generated by the Verum Omnis Contradiction Engine."
        const val PATENT_NOTICE = "Patent Pending - Verum Omnis"
    }
    
    private val dateFormat = SimpleDateFormat("MMMM d, yyyy", Locale.US)
    private val dateTimeFormat = SimpleDateFormat("MMMM d, yyyy 'at' h:mm a", Locale.US)
    
    /**
     * Generate a complete forensic narrative.
     *
     * @param caseTitle Title for the case
     * @param statementIndex Index of all statements
     * @param entityProfiles Map of entity profiles
     * @param timelineEvents List of timeline events
     * @param contradictionReport Full contradiction report
     * @return Complete narrative as a NarrativeOutput object
     */
    fun generateNarrative(
        caseTitle: String,
        statementIndex: StatementIndex,
        entityProfiles: Map<String, EntityProfile>,
        timelineEvents: List<TimelineEvent>,
        contradictionReport: ContradictionReport
    ): NarrativeOutput {
        val sections = mutableListOf<NarrativeSection>()
        
        // Section 1: Title and Introduction
        sections.add(generateIntroduction(caseTitle, contradictionReport))
        
        // Section 2: Summary Paragraph
        sections.add(generateSummaryParagraph(contradictionReport))
        
        // Section 3: Parties Involved
        sections.add(generatePartiesSection(entityProfiles))
        
        // Section 4: Full Chronological Narrative with Embedded Contradictions
        sections.add(generateChronologicalNarrative(
            timelineEvents, 
            contradictionReport.contradictions,
            statementIndex
        ))
        
        // Section 5: Behavioral Analysis
        sections.add(generateBehavioralAnalysisSection(
            contradictionReport.behavioralAnomalies,
            entityProfiles
        ))
        
        // Section 6: Financial Inconsistencies
        sections.add(generateFinancialInconsistenciesSection(
            contradictionReport.contradictions.filter { it.type == ContradictionType.FINANCIAL },
            entityProfiles
        ))
        
        // Section 7: Legal Triggers
        sections.add(generateLegalTriggersSection(contradictionReport.legalTriggers))
        
        // Section 8: Final Forensic Summary
        sections.add(generateForensicSummary(contradictionReport))
        
        // Build the complete narrative text
        val fullText = buildFullNarrativeText(sections)
        
        return NarrativeOutput(
            title = caseTitle,
            generatedAt = System.currentTimeMillis(),
            sections = sections,
            fullText = fullText,
            contradictionCount = contradictionReport.totalContradictions,
            entityCount = entityProfiles.size,
            documentCount = statementIndex.getDocuments().size
        )
    }
    
    /**
     * Generate the introduction section.
     */
    private fun generateIntroduction(
        caseTitle: String,
        report: ContradictionReport
    ): NarrativeSection {
        val content = buildString {
            appendLine("FORENSIC ANALYSIS REPORT")
            appendLine("========================")
            appendLine()
            appendLine("Case: $caseTitle")
            appendLine("Case ID: ${report.caseId}")
            appendLine("Generated: ${dateTimeFormat.format(Date())}")
            appendLine()
            appendLine("This report presents a comprehensive forensic analysis of the documentary")
            appendLine("evidence submitted for review. The analysis employed multi-pass contradiction")
            appendLine("detection, semantic analysis, timeline verification, entity profiling, and")
            appendLine("behavioral pattern recognition to identify inconsistencies, conflicts, and")
            appendLine("potential legal implications within the evidence.")
        }
        
        return NarrativeSection(
            title = "Introduction",
            content = content,
            type = NarrativeSectionType.INTRODUCTION
        )
    }
    
    /**
     * Generate the summary paragraph.
     */
    private fun generateSummaryParagraph(report: ContradictionReport): NarrativeSection {
        val critical = report.contradictions.count { it.severity >= 8 }
        val high = report.contradictions.count { it.severity in 6..7 }
        val medium = report.contradictions.count { it.severity in 4..5 }
        
        val content = buildString {
            appendLine("EXECUTIVE SUMMARY")
            appendLine("-----------------")
            appendLine()
            append("Analysis of the submitted evidence has identified a total of ")
            append("${report.totalContradictions} contradictions, ")
            append("${report.timelineConflicts.size} timeline conflicts, and ")
            append("${report.behavioralAnomalies.size} behavioral anomalies. ")
            
            if (critical > 0) {
                append("Of these, $critical are classified as CRITICAL, indicating findings ")
                append("that may significantly impact liability determinations. ")
            }
            
            if (high > 0) {
                append("An additional $high are classified as HIGH severity, ")
                append("suggesting potential dishonest intent. ")
            }
            
            appendLine()
            appendLine()
            
            // Key findings
            if (report.legalTriggers.isNotEmpty()) {
                appendLine("The analysis has identified the following potential legal triggers:")
                for (trigger in report.legalTriggers.take(5)) {
                    appendLine("  ‚Ä¢ ${trigger.trigger}: ${trigger.description}")
                }
            }
        }
        
        return NarrativeSection(
            title = "Executive Summary",
            content = content,
            type = NarrativeSectionType.SUMMARY
        )
    }
    
    /**
     * Generate the parties section from entity profiles.
     */
    private fun generatePartiesSection(profiles: Map<String, EntityProfile>): NarrativeSection {
        val content = buildString {
            appendLine("PARTIES INVOLVED")
            appendLine("----------------")
            appendLine()
            
            for ((name, profile) in profiles) {
                appendLine("${profile.name}")
                if (profile.role.isNotBlank()) {
                    appendLine("  Role: ${profile.role}")
                }
                if (profile.aliases.isNotEmpty()) {
                    appendLine("  Also known as: ${profile.aliases.joinToString(", ")}")
                }
                
                // Summarize actions
                val actionCount = profile.actions.size
                val claimCount = profile.claims.size
                appendLine("  Statements on record: $claimCount")
                appendLine("  Documented actions: $actionCount")
                
                // Behavioral summary
                val patterns = profile.behavioralProfile.patterns
                if (patterns.isNotEmpty()) {
                    appendLine("  Detected behavioral patterns: ${patterns.joinToString(", ") { it.name.lowercase().replace("_", " ") }}")
                }
                
                // Contradictions involving this party
                appendLine()
            }
        }
        
        return NarrativeSection(
            title = "Parties Involved",
            content = content,
            type = NarrativeSectionType.PARTIES
        )
    }
    
    /**
     * Generate the chronological narrative with embedded contradictions.
     */
    private fun generateChronologicalNarrative(
        events: List<TimelineEvent>,
        contradictions: List<Contradiction>,
        statementIndex: StatementIndex
    ): NarrativeSection {
        val sortedEvents = events.sortedBy { it.timestampMillis }
        val contradictionsByStatement = contradictions
            .flatMap { c -> listOf(c.sourceStatement.id to c, c.targetStatement.id to c) }
            .groupBy { it.first }
            .mapValues { it.value.map { p -> p.second }.distinct() }
        
        val content = buildString {
            appendLine("CHRONOLOGICAL NARRATIVE")
            appendLine("-----------------------")
            appendLine()
            appendLine("The following narrative presents events in chronological order,")
            appendLine("with contradictions and inconsistencies embedded at relevant points.")
            appendLine()
            
            var currentDate = ""
            
            for (event in sortedEvents) {
                val eventDate = if (event.timestampMillis > 0) dateFormat.format(Date(event.timestampMillis)) else (event.timestamp ?: "Unknown date")
                
                // New date header
                if (eventDate != currentDate) {
                    currentDate = eventDate
                    appendLine()
                    appendLine("--- $currentDate ---")
                    appendLine()
                }
                
                // Event description
                val speaker = event.entityIds.firstOrNull() ?: "Unknown"
                append("$speaker: ")
                appendLine(event.description)
                
                // Check for contradictions related to this event's statements
                for (statementId in event.statementIds) {
                    val relatedContradictions = contradictionsByStatement[statementId] ?: emptyList()
                    for (contradiction in relatedContradictions) {
                        appendLine()
                        append("    ‚ö†Ô∏è CONTRADICTION DETECTED (Severity: ${contradiction.severity}/10): ")
                        appendLine(formatContradictionForNarrative(contradiction))
                        if (contradiction.legalTrigger != null) {
                            appendLine("    üìã Legal Implication: ${getLegalImplicationText(contradiction.legalTrigger)}")
                        }
                        appendLine()
                    }
                }
            }
        }
        
        return NarrativeSection(
            title = "Chronological Narrative",
            content = content,
            type = NarrativeSectionType.CHRONOLOGY
        )
    }
    
    /**
     * Generate the behavioral analysis section.
     */
    private fun generateBehavioralAnalysisSection(
        anomalies: List<BehavioralAnomaly>,
        profiles: Map<String, EntityProfile>
    ): NarrativeSection {
        val content = buildString {
            appendLine("BEHAVIORAL ANALYSIS")
            appendLine("-------------------")
            appendLine()
            
            if (anomalies.isEmpty()) {
                appendLine("No significant behavioral anomalies were detected in the analyzed statements.")
                return@buildString
            }
            
            appendLine("Analysis of communication patterns has revealed the following behavioral")
            appendLine("observations that may be relevant to assessing credibility and intent:")
            appendLine()
            
            // Group anomalies by entity
            val byEntity = anomalies.groupBy { it.entityId }
            
            for ((entityId, entityAnomalies) in byEntity) {
                val profile = profiles[entityId]
                val entityName = profile?.name ?: entityId
                
                appendLine("$entityName:")
                appendLine()
                
                for (anomaly in entityAnomalies) {
                    appendLine("  ‚Ä¢ ${getBehavioralInsight(anomaly)}")
                }
                
                appendLine()
            }
            
            // Natural language behavioral conclusions
            appendLine("Behavioral Conclusions:")
            appendLine()
            
            for ((entityId, entityAnomalies) in byEntity) {
                val profile = profiles[entityId]
                val entityName = profile?.name ?: entityId
                
                val conclusions = generateBehavioralConclusions(entityAnomalies)
                for (conclusion in conclusions) {
                    appendLine("  - $entityName: $conclusion")
                }
            }
        }
        
        return NarrativeSection(
            title = "Behavioral Analysis",
            content = content,
            type = NarrativeSectionType.BEHAVIORAL
        )
    }
    
    /**
     * Generate the financial inconsistencies section.
     */
    private fun generateFinancialInconsistenciesSection(
        financialContradictions: List<Contradiction>,
        profiles: Map<String, EntityProfile>
    ): NarrativeSection {
        val content = buildString {
            appendLine("FINANCIAL INCONSISTENCIES")
            appendLine("-------------------------")
            appendLine()
            
            if (financialContradictions.isEmpty()) {
                appendLine("No significant financial inconsistencies were detected in the analyzed documents.")
                return@buildString
            }
            
            appendLine("The following financial discrepancies were identified during analysis:")
            appendLine()
            
            for (contradiction in financialContradictions) {
                appendLine("‚Ä¢ ${contradiction.description}")
                appendLine("  Source: ${contradiction.sourceDocument}")
                appendLine("  Severity: ${contradiction.severity}/10")
                if (contradiction.legalTrigger != null) {
                    appendLine("  Legal implication: ${getLegalImplicationText(contradiction.legalTrigger)}")
                }
                appendLine()
            }
            
            // Summary of financial impact
            val totalFinancialContradictions = financialContradictions.size
            val avgSeverity = financialContradictions.map { it.severity }.average()
            
            appendLine("Summary: $totalFinancialContradictions financial inconsistencies detected")
            appendLine("Average severity: ${String.format("%.1f", avgSeverity)}/10")
        }
        
        return NarrativeSection(
            title = "Financial Inconsistencies",
            content = content,
            type = NarrativeSectionType.FINANCIAL
        )
    }
    
    /**
     * Generate the legal triggers section.
     */
    private fun generateLegalTriggersSection(
        triggers: List<LegalTriggerEvidence>
    ): NarrativeSection {
        val content = buildString {
            appendLine("LEGAL TRIGGERS AND IMPLICATIONS")
            appendLine("-------------------------------")
            appendLine()
            
            if (triggers.isEmpty()) {
                appendLine("No specific legal triggers were identified based on the contradictions detected.")
                return@buildString
            }
            
            appendLine("Based on the contradictions and inconsistencies identified, the following")
            appendLine("potential legal implications have been flagged for consideration:")
            appendLine()
            
            for (trigger in triggers.sortedByDescending { it.confidence }) {
                appendLine("${trigger.trigger}")
                appendLine("-".repeat(trigger.trigger.name.length))
                appendLine()
                appendLine("Description: ${trigger.description}")
                appendLine()
                appendLine("Confidence: ${String.format("%.0f", trigger.confidence * 100)}%")
                appendLine("Supporting evidence: ${trigger.supportingContradictionIds.size} contradictions")
                appendLine()
                appendLine("Recommendation: ${trigger.recommendation}")
                appendLine()
                appendLine()
            }
        }
        
        return NarrativeSection(
            title = "Legal Triggers",
            content = content,
            type = NarrativeSectionType.LEGAL_TRIGGERS
        )
    }
    
    /**
     * Generate the final forensic summary.
     */
    private fun generateForensicSummary(report: ContradictionReport): NarrativeSection {
        val content = buildString {
            appendLine("FINAL FORENSIC SUMMARY")
            appendLine("======================")
            appendLine()
            
            appendLine("This forensic analysis has examined the submitted documentary evidence")
            appendLine("and identified the following key findings:")
            appendLine()
            
            // Statistics
            appendLine("STATISTICS:")
            appendLine("  ‚Ä¢ Total contradictions: ${report.totalContradictions}")
            appendLine("  ‚Ä¢ Timeline conflicts: ${report.timelineConflicts.size}")
            appendLine("  ‚Ä¢ Behavioral anomalies: ${report.behavioralAnomalies.size}")
            appendLine("  ‚Ä¢ Entities analyzed: ${report.affectedEntities.size}")
            appendLine("  ‚Ä¢ Documents reviewed: ${report.documentLinks.size}")
            appendLine()
            
            // Severity breakdown
            appendLine("SEVERITY BREAKDOWN:")
            for ((severity, count) in report.severityBreakdown.entries.sortedByDescending { it.key }) {
                val label = when (severity) {
                    10, 9 -> "CRITICAL"
                    8, 7 -> "HIGH"
                    6, 5 -> "MEDIUM"
                    else -> "LOW"
                }
                appendLine("  ‚Ä¢ $label ($severity): $count contradictions")
            }
            appendLine()
            
            // Critical findings
            val critical = report.contradictions.filter { it.severity >= 8 }
            if (critical.isNotEmpty()) {
                appendLine("CRITICAL FINDINGS:")
                for (c in critical.take(5)) {
                    appendLine("  ‚Ä¢ ${c.description}")
                }
                if (critical.size > 5) {
                    appendLine("  ... and ${critical.size - 5} more critical findings")
                }
                appendLine()
            }
            
            // Legal risks
            if (report.legalTriggers.isNotEmpty()) {
                appendLine("IDENTIFIED LEGAL RISKS:")
                for (trigger in report.legalTriggers) {
                    appendLine("  ‚Ä¢ ${trigger.trigger}: ${trigger.description}")
                }
                appendLine()
            }
            
            // Conclusion
            appendLine("CONCLUSION:")
            appendLine()
            
            if (report.totalContradictions > 0) {
                val avgSeverity = report.contradictions.map { it.severity }.average()
                val overallAssessment = when {
                    critical.size >= 3 || avgSeverity >= 7 -> 
                        "The evidence contains SIGNIFICANT contradictions that warrant serious legal consideration."
                    critical.isNotEmpty() || avgSeverity >= 5 -> 
                        "The evidence contains NOTABLE contradictions that should be addressed in legal proceedings."
                    else -> 
                        "The evidence contains MINOR inconsistencies that may require clarification."
                }
                appendLine(overallAssessment)
            } else {
                appendLine("The evidence reviewed does not contain significant contradictions or inconsistencies.")
            }
            
            appendLine()
            appendLine("---")
            appendLine(BRANDING_NOTICE)
            appendLine(PATENT_NOTICE)
        }
        
        return NarrativeSection(
            title = "Final Summary",
            content = content,
            type = NarrativeSectionType.FINAL_SUMMARY
        )
    }
    
    /**
     * Build the complete narrative text from all sections.
     */
    private fun buildFullNarrativeText(sections: List<NarrativeSection>): String {
        return sections.joinToString("\n\n\n") { it.content }
    }
    
    /**
     * Format a contradiction for embedding in the narrative.
     */
    private fun formatContradictionForNarrative(contradiction: Contradiction): String {
        return buildString {
            append("This statement contradicts earlier evidence. ")
            append("Earlier: \"${contradiction.sourceStatement.text.take(60)}...\" ")
            append("Later: \"${contradiction.targetStatement.text.take(60)}...\" ")
            append("This represents a ${getSeverityText(contradiction.severity)} inconsistency.")
        }
    }
    
    /**
     * Get human-readable text for severity level.
     */
    private fun getSeverityText(severity: Int): String {
        return when {
            severity >= 9 -> "critical"
            severity >= 7 -> "significant"
            severity >= 5 -> "notable"
            else -> "minor"
        }
    }
    
    /**
     * Get legal implication text for a trigger.
     */
    private fun getLegalImplicationText(trigger: LegalTrigger): String {
        return when (trigger) {
            LegalTrigger.FRAUD -> "Potential fraud - intentional deception for gain"
            LegalTrigger.MISREPRESENTATION -> "Possible misrepresentation of material facts"
            LegalTrigger.CONCEALMENT -> "Evidence of concealment or non-disclosure"
            LegalTrigger.PERJURY_RISK -> "Statements may constitute perjury if made under oath"
            LegalTrigger.BREACH_OF_CONTRACT -> "Potential breach of contractual obligations"
            LegalTrigger.TIMELINE_INCONSISTENCY -> "Chronological claims are unreliable"
            LegalTrigger.UNRELIABLE_TESTIMONY -> "Testimony credibility is compromised"
            LegalTrigger.FINANCIAL_DISCREPANCY -> "Financial figures require reconciliation"
            LegalTrigger.CONFLICT_OF_INTEREST -> "Undisclosed conflict of interest detected"
            LegalTrigger.NEGLIGENCE -> "Potential breach of duty of care"
        }
    }
    
    /**
     * Get behavioral insight text for an anomaly.
     */
    private fun getBehavioralInsight(anomaly: BehavioralAnomaly): String {
        return when (anomaly.type) {
            BehavioralAnomalyType.SUDDEN_DENIAL -> 
                "Sudden denial after prior certainty - credibility concern"
            BehavioralAnomalyType.TONE_SHIFT -> 
                "Tone shifted from ${anomaly.beforeState} to ${anomaly.afterState}"
            BehavioralAnomalyType.CONFIDENCE_DECLINE -> 
                "Confidence declined from ${anomaly.beforeState} to ${anomaly.afterState}"
            BehavioralAnomalyType.VAGUENESS_INCREASE -> 
                "Statements became increasingly vague after key events"
            BehavioralAnomalyType.DEFLECTION_PATTERN -> 
                "Pattern of deflection detected across multiple statements"
            BehavioralAnomalyType.OVER_EXPLAINING -> 
                "Over-explaining behavior detected (potential fraud indicator)"
            BehavioralAnomalyType.BLAME_SHIFTING -> 
                "Consistent pattern of shifting blame to others"
            BehavioralAnomalyType.WITHDRAWAL -> 
                "Sudden withdrawal or non-responsiveness pattern"
            BehavioralAnomalyType.GASLIGHTING -> 
                "Gaslighting language detected - attempting to distort reality"
            BehavioralAnomalyType.PRESSURE_TACTICS -> 
                "Use of pressure tactics in communications"
        }
    }
    
    /**
     * Generate behavioral conclusions.
     */
    private fun generateBehavioralConclusions(anomalies: List<BehavioralAnomaly>): List<String> {
        val conclusions = mutableListOf<String>()
        
        // Check for confidence decline
        if (anomalies.any { it.type == BehavioralAnomalyType.CONFIDENCE_DECLINE }) {
            conclusions.add("Confidence declines after legal triggers are raised")
        }
        
        // Check for tone shifts
        if (anomalies.any { it.type == BehavioralAnomalyType.TONE_SHIFT }) {
            conclusions.add("Tone shifts from cooperative to defensive")
        }
        
        // Check for vagueness
        if (anomalies.any { it.type == BehavioralAnomalyType.VAGUENESS_INCREASE }) {
            conclusions.add("Statements become vague after contradictions arise")
        }
        
        // Check for deflection
        if (anomalies.any { it.type == BehavioralAnomalyType.DEFLECTION_PATTERN }) {
            conclusions.add("Consistent pattern of deflection when questioned")
        }
        
        return conclusions
    }
}

/**
 * Represents a section of the narrative.
 */
data class NarrativeSection(
    val title: String,
    val content: String,
    val type: NarrativeSectionType,
    val contradictions: List<String> = emptyList()
)

/**
 * Types of narrative sections.
 */
enum class NarrativeSectionType {
    INTRODUCTION,
    SUMMARY,
    PARTIES,
    CHRONOLOGY,
    CONTRADICTIONS,
    BEHAVIORAL,
    FINANCIAL,
    LEGAL_TRIGGERS,
    FINAL_SUMMARY
}

/**
 * Complete narrative output.
 */
data class NarrativeOutput(
    val title: String,
    val generatedAt: Long,
    val sections: List<NarrativeSection>,
    val fullText: String,
    val contradictionCount: Int,
    val entityCount: Int,
    val documentCount: Int
) {
    /**
     * Get the narrative as searchable text for PDF text layer.
     */
    fun getSearchableText(): String = fullText
    
    /**
     * Get sections by type.
     */
    fun getSectionByType(type: NarrativeSectionType): NarrativeSection? {
        return sections.find { it.type == type }
    }
}
